<script>
	import {
		OrbitControls,
		Three,
		useFrame,
		useLoader,
		useThrelte,
	} from '@threlte/core';
	import {
		PerspectiveCamera,
		ShaderMaterial,
		RGBAFormat,
		FloatType,
		DataTexture,
		AdditiveBlending,
		AmbientLight,
		Matrix4,
		NearestFilter,
		MathUtils,
		Mesh,
		MeshBasicMaterial,
		Vector4,
	} from 'three';
	import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
	import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';

	import FBO from './lib/fbo';

	import simulationVertex from './shaders/simulation/vertexShader';
	import simulationFragment from './shaders/simulation/fragmentShader';
	import particleVertex from './shaders/particles/vertexShader';
	import particleFragment from './shaders/particles/fragmentShader';
	import { getRandomData, randomPointsInBufferGeometry } from './lib/util.js';

	const { renderer, scene } = useThrelte();

	export let sliderValue;

	let font;

	const fontLoader = useLoader(FontLoader, () => new FontLoader());
	fontLoader.load('src/assets/yahei_bold.json', (f) => {
		font = f;
		init();
	});

	let fbo;

	const getTextTexture = (textGeo) => {
		const data = new Float32Array(256 * 256 * 4);
		const points = randomPointsInBufferGeometry(textGeo, 256 * 256);

		for (let i = 0, j = 0; i < data.length; i += 4, j += 1) {
			data[i] = points[j].x;
			data[i + 1] = points[j].y;
			data[i + 2] = points[j].z;
			data[i + 3] = 1.0;
		}

		const texture = new DataTexture(
			data,
			256,
			256,
			RGBAFormat,
			FloatType
		);
		texture.minFilter = NearestFilter;
		texture.magFilter = NearestFilter;
		texture.needsUpdate = true;

		return texture;
	}

	const init = () => {
		const width = 256;
		const height = 256;

		const textA = new TextGeometry('女', {
			font,
			size: 0.5,
			height: 0.1,
			curveSegments: 12,
		});

		const textureA = getTextTexture(textA);

		const textB = new TextGeometry('男', {
			font,
			size: 0.5,
			height: 0.1,
			curveSegments: 12,
		});

		const textureC = getTextTexture(textB);

		//second model
		const dataB = getRandomData(width, height);
		const textureB = new DataTexture(
			dataB,
			width,
			height,
			RGBAFormat,
			FloatType
		);
		textureB.needsUpdate = true;

		const simulationShader = new ShaderMaterial({
			uniforms: {
				textureA: { value: textureA },
				textureB: { value: textureB },
				textureC: { value: textureC },
				timer: { value: 0 },
			},
			vertexShader: simulationVertex,
			fragmentShader: simulationFragment,
		});

		const renderShader = new ShaderMaterial({
			uniforms: {
				positions: { value: null },
				pointSize: { value: 10.0 },
				alpha: { value: 1.0 },
			},
			vertexShader: particleVertex,
			fragmentShader: particleFragment,
			transparent: true,
			blending: AdditiveBlending,
		});

		fbo = new FBO(width, height, renderer, simulationShader, renderShader);

		scene.add(fbo.particles);
	};

	useFrame(() => {
		fbo?.update(sliderValue);
	});
</script>

<Three type={PerspectiveCamera} makeDefault position={[0, 0, 2.5]} fov={60}>
	<OrbitControls />
</Three>

<!-- <Three type={Mesh} geometry={textGeometry} material={new MeshBasicMaterial()} /> -->

<Three type={AmbientLight} intensity={0.5} />
